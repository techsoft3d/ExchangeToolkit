<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Exchange Toolkit: Data Access</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ExchangeToolkit.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Exchange Toolkit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Data Access </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#access_challenge">The Challenge</a></li>
<li class="level1"><a href="#access_data_wrapper">Concept: Wrapper Macros</a></li>
<li class="level1"><a href="#instance_section">Concept: Instance</a></li>
<li class="level1"><a href="#Arrays">Arrays</a></li>
<li class="level1"><a href="#Tessellation">Tessellation</a><ul><li class="level2"><a href="#Faces">Faces</a></li>
<li class="level2"><a href="#Edges">Edges</a></li>
<li class="level2"><a href="#Wires">Wires</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="access_challenge"></a>
The Challenge</h1>
<p>If you are familiar with the Exchange API, then you have almost certainly seen this pattern before: </p><div class="fragment"><div class="line"><span class="comment">// Assume you have some product occurrence and want to get its contents...</span></div><div class="line">A3DAsmProductOccurrence *po = getSomePO();</div><div class="line"></div><div class="line"><span class="comment">// First you must declare a struct to hold data</span></div><div class="line">A3DAsmProductOccurrenceData po_data;</div><div class="line"></div><div class="line"><span class="comment">// Second, you must initialize the struct so it can be used</span></div><div class="line">A3D_INITIALIZE_DATA(A3DAsmProductOccurrenceData, po_data);</div><div class="line"></div><div class="line"><span class="comment">// Then you can retrieve the data</span></div><div class="line">A3DAsmProductOccurrenceGet( po, &amp;po_data );</div><div class="line"></div><div class="line"><span class="comment">// And now you can use the data</span></div><div class="line">partProcessingAlgorithm( po_data.m_pPart );</div><div class="line"></div><div class="line"><span class="comment">// Finally, you must free any dynamic resources by calling</span></div><div class="line">A3DAsmProductOccurrenceGet( <span class="keyword">nullptr</span>, &amp;po_data );</div></div><!-- fragment --><p> Most programmers would agree that this is verbose and error prone. </p>
<h1><a class="anchor" id="access_data_wrapper"></a>
Concept: Wrapper Macros</h1>
<p>The Exchange Toolkit provides a solution to this pattern by exposing the macro <a class="el" href="group__access.html#ga80137872855c9e337de5bca8d0517944" title="This macro is used to define a struct that can be used to more easily obtain and access the Exchange ...">A3D_HELPERS( A3D_VOID_TYPE )</a>. This macro is expanded for many of the Exchange data types which results in a set of structs that can be used to read data from the Exchange API in a more concise way.</p>
<p>In order to make the concept more clear let's take a look at the following code snippet, which is <em>similar</em> to the code expansion of the macro <a class="el" href="group__access.html#ga80137872855c9e337de5bca8d0517944" title="This macro is used to define a struct that can be used to more easily obtain and access the Exchange ...">A3D_HELPERS( A3DAsmModelFile )</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacets3d.html">ts3d</a> {</div><div class="line">    <span class="keyword">struct </span>A3DAsmModelFileWrapper {</div><div class="line">        <span class="comment">// Acquire resources on creation</span></div><div class="line">        <a class="code" href="structts3d_1_1_a3_d_asm_model_file_wrapper.html#a4c18d094e580eeda1995b72b3ef27f1d">A3DAsmModelFileWrapper</a>( A3DAsmModelFile *p ) {</div><div class="line">            A3D_INITIALIZE_DATA( A3DAsmModelFileData, <a class="code" href="structts3d_1_1_a3_d_asm_model_file_wrapper.html#a79ad19a52104d3ac7472776bd8ca38ef">_d</a> );</div><div class="line">            <span class="keywordflow">if</span>( p ) {</div><div class="line">                A3DAsmModelFileGet( p, &amp;<a class="code" href="structts3d_1_1_a3_d_asm_model_file_wrapper.html#a79ad19a52104d3ac7472776bd8ca38ef">_d</a> );</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Free resources on destroy</span></div><div class="line">        <a class="code" href="structts3d_1_1_a3_d_asm_model_file_wrapper.html#af797b583b1698bff995a42795226bae0">~A3DAsmModelFileWrapper</a>( A3DAsmModelFile *p ) {</div><div class="line">            A3DAsmModelFileGet( <span class="keyword">nullptr</span>, &amp;<a class="code" href="structts3d_1_1_a3_d_asm_model_file_wrapper.html#a79ad19a52104d3ac7472776bd8ca38ef">_d</a> );</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Concise data access</span></div><div class="line">        A3DAsmModelFileData *<a class="code" href="structts3d_1_1_a3_d_asm_model_file_wrapper.html#acd47148c0648d3ec6ad46b637063edb0">operator-&gt;</a>( <span class="keywordtype">void</span> ) {</div><div class="line">            <span class="keywordflow">return</span> &amp;<a class="code" href="structts3d_1_1_a3_d_asm_model_file_wrapper.html#a79ad19a52104d3ac7472776bd8ca38ef">_d</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Convenience function for reassignment</span></div><div class="line">        <span class="keywordtype">void</span> <a class="code" href="structts3d_1_1_a3_d_asm_model_file_wrapper.html#ab43ddd1538242964c0163b46615b091a">reset</a>( A3DAsmModelFile *p ) {</div><div class="line">            A3DAsmModelFileGet(<span class="keyword">nullptr</span>, &amp;<a class="code" href="structts3d_1_1_a3_d_asm_model_file_wrapper.html#a79ad19a52104d3ac7472776bd8ca38ef">_d</a> );</div><div class="line">            <span class="keywordflow">if</span>( p ) {</div><div class="line">                A3DAsmModelFileGet( p, &amp;<a class="code" href="structts3d_1_1_a3_d_asm_model_file_wrapper.html#a79ad19a52104d3ac7472776bd8ca38ef">_d</a> );</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        A3DAsmModelFileData <a class="code" href="structts3d_1_1_a3_d_asm_model_file_wrapper.html#a79ad19a52104d3ac7472776bd8ca38ef">_d</a>;</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p>With this implementation, we now have easy access to the data from the Exchange API. If we rewrite the <code>doSomething</code> code from above, it might look like this: </p><div class="fragment"><div class="line"><span class="comment">// Assume you have some product occurrence and want to get its contents...</span></div><div class="line">A3DAsmProductOccurrence *po = getSomePO();</div><div class="line"></div><div class="line"><span class="comment">// Declare the wrapper for concise access to the Exchange Data</span></div><div class="line"><a class="code" href="structts3d_1_1_a3_d_asm_product_occurrence_wrapper.html">ts3d::A3DAsmProductOccurrenceWrapper</a> d( po );</div><div class="line"></div><div class="line"><span class="comment">// And now you can use the data</span></div><div class="line">partProcessingAlgorithm( d-&gt;m_pPart );</div></div><!-- fragment --><p>Or, if you want to go crazy with concise code, simply write: </p><div class="fragment"><div class="line"><span class="comment">// A little ugly, but could be one line!</span></div><div class="line">partProcessingAlgorithm( ts3d::A3DAsmProductOccurrentWrapper( getSomePO() )-&gt;m_pPart );</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__wrappers.html" title="This is a complete list of data access wrappers. Every object in HOOPS Exchange with a typename match...">Data Access Wrappers</a></dd></dl>
<h1><a class="anchor" id="instance_section"></a>
Concept: Instance</h1>
<p>The class <a class="el" href="classts3d_1_1_instance.html" title="An instance should be thought of as a specific path through the Exchange product structure to a parti...">ts3d::Instance</a> provides additional functionality for computing "net attributes" that are based on a specific <a class="el" href="group__traversal.html#ga2550c35e83a8d01e9a0155a084a5166d" title="The InstancePath type is used to identify a particular path through the hierarchy of Exchange objects...">ts3d::InstancePath</a>.</p>
<p>To understand this better, lets consider the specific example of a part that is instanced multple times in a model. A bolt is a great example of this because one bolt size is often used throughout a model, with each instance having a different world position.</p>
<p>The world position of each bolt instance is determined by the nodes of the assembly tree that contain it. Each node of the assembly tree imparts a local transformation, and once reaching the leaf node of the product structure, you arrive at a part instance of the bolt with some final accumulated transform.</p>
<p>Without the help of the Exchange Toolkit, one would have to write recursive code to traverse the assembly hierarchy. At each node of the traversal, you must obtain the node's transform and accumulate the transform with those previously encountered. To further complicate this task, <code>A3DAsmProductOccurrence</code> objects store their transform in two different ways.</p>
<p>The <a class="el" href="classts3d_1_1_instance.html" title="An instance should be thought of as a specific path through the Exchange product structure to a parti...">ts3d::Instance</a> class makes this task easier when used with the function <a class="el" href="group__eigen__bridge.html#gabe127bcb8cffb23d2b7de2b694a6cd8a" title="Gets the net matrix for a given instance.The matrix of each entry in the instance path is obtained an...">ts3d::getNetMatrix()</a>. Similarly, there are several attributes whose final (or "net") values are determined by the path taken through the assembly hierarchy to arrive at a particular leaf node.</p>
<p>Coupling this class with the Traversal functionality from exchange, you can easily obtain net attributes from individual parts by writing the following code: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> parts = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( loader.m_psModelFile, kA3DTypeAsmPartDefinition );</div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span> <span class="keyword">const</span> part_path : parts ) {</div><div class="line">    <a class="code" href="classts3d_1_1_instance.html">ts3d::Instance</a> part_instance( part_path );</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Net Matrix: &quot;</span> &lt;&lt; <a class="code" href="group__eigen__bridge.html#gabe127bcb8cffb23d2b7de2b694a6cd8a">ts3d::getNetMatrix</a>( part_instance );</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="group__eigen__bridge.html#gabe127bcb8cffb23d2b7de2b694a6cd8a" title="Gets the net matrix for a given instance.The matrix of each entry in the instance path is obtained an...">ts3d::getNetMatrix()</a> returns a <a class="el" href="group__eigen__bridge.html#ga0c7b76c1cf478d0990600af2e5e193a8" title="Alias for a 4x4 matrix type. ">ts3d::MatrixType</a>, which is defined in the <a class="el" href="group__eigen__bridge.html">Eigen Bridge</a>.</dd></dl>
<h1><a class="anchor" id="Arrays"></a>
Arrays</h1>
<p>The Exchange API often contains C-style arrays. The struct containing the array will typically have two data members, one for the pointer and another for the size of the array.</p>
<p>For convenience, the Exchange Toolkit provides the function <a class="el" href="group__access.html#gaa4d94fe611fbd8d9dfecb960e263d4a1" title="This function can be used to more easily construct a vector of objects. ">ts3d::toVector</a> for converting these arrays to std::vector objects.</p>
<p>As an example, the traditional implementation: </p><div class="fragment"><div class="line"><span class="comment">// Declare</span></div><div class="line">A3DAsmProductOccurrenceData d;</div><div class="line"></div><div class="line"><span class="comment">// Initialize</span></div><div class="line">A3D_INITIALIZE_DATA( A3DAsmProductOccurrenceData, d );</div><div class="line"></div><div class="line"><span class="comment">// Get</span></div><div class="line">A3DAsmProductOccurrenceGet( po, &amp;d );</div><div class="line"></div><div class="line"><span class="comment">// C-style Loop</span></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span> idx = 0u; idx &lt; d.m_uiPOccurrenceSize; ++idx ) {</div><div class="line">    doSomethingWithChild( d.m_ppPOccurrences[idx] );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Free</span></div><div class="line">A3DAsmProductOccurrenceGet( <span class="keyword">nullptr</span>, &amp;d );</div></div><!-- fragment --><p> Can be rewritten as: </p><div class="fragment"><div class="line"><span class="comment">// Use the data access wrapper</span></div><div class="line"><a class="code" href="structts3d_1_1_a3_d_asm_product_occurrence_wrapper.html">ts3d::A3DAsmProductOccurrenceWrapper</a> d( po );</div><div class="line"></div><div class="line"><span class="comment">// C++ style loop</span></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span> <span class="keyword">const</span> child_po : <a class="code" href="group__access.html#gaa4d94fe611fbd8d9dfecb960e263d4a1">ts3d::toVector</a>( d-&gt;m_ppPOccurrences, d-&gt;m_uiPOccurrencesSize ) ) {</div><div class="line">    doSomethingWithChild( child_po );</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Tessellation"></a>
Tessellation</h1>
<p>The Exchange API provides access to a tessellated representation of data in the form of triangles, triangle strips and triangle fans. There are variations of the form this data takes depending on the presence of per-vertex normal vectors, or texture coordinates. This variation results in about 12 different cases for parsing the tessellation.</p>
<p>Many tessellation-based use cases are concerned with triangle primitives only. Fans and strips must be decomposed, along with normal vectors and texture coordinates. This simplification of the Exchange data set can lead to confusion and is indeed error prone.</p>
<p>To address this challenge, the Exchange Toolkit provides some tools and objects making access to an index mesh much easier.</p>
<p>The class <a class="el" href="classts3d_1_1_representation_item_instance.html" title="This specific type of an Instance expects the leaf node to be of type kA3DTypeRiRepresentationItem. ">ts3d::RepresentationItemInstance</a> is the entry point to obtaining the simplified tessellation data. Since represenation items contain the tessellation, this class requires a <a class="el" href="group__traversal.html#ga2550c35e83a8d01e9a0155a084a5166d" title="The InstancePath type is used to identify a particular path through the hierarchy of Exchange objects...">ts3d::InstancePath</a> with a leaf node type that is a represenation item. Once constructed, used the method <a class="el" href="classts3d_1_1_representation_item_instance.html#a050aa55609a8901c39d04cfd6b0e1a87" title="Provides a concrete type for the tessellation instance Will be one of type: ">ts3d::RepresentationItemInstance::getTessellation()</a> to obtain the data.</p>
<h2><a class="anchor" id="Faces"></a>
Faces</h2>
<p>The Exchange toolkit provides an abstraction that simplifies access to the triangles that make up a topological face. The class that provides this functionality is <a class="el" href="classts3d_1_1_tess3_d_instance.html" title="Encapsulates the functionality desired to easily retrieve normal and texture coordinates for a tessel...">ts3d::Tess3DInstance</a>. This is a concrete implementation of <a class="el" href="classts3d_1_1_tess_base_instance.html" title="Base class for easing access to tessellation data. Provides access to coordinate values. ">ts3d::TessBaseInstance</a> returned from the call to <a class="el" href="classts3d_1_1_representation_item_instance.html#a050aa55609a8901c39d04cfd6b0e1a87" title="Provides a concrete type for the tessellation instance Will be one of type: ">ts3d::RepresentationItemInstance::getTessellation()</a>. From this object you can obtain a <a class="el" href="classts3d_1_1_tess_face_data_helper.html" title="This is a helper class used to more easily provide access to the indexed mesh data for a given face...">ts3d::TessFaceDataHelper</a> object for each face.</p>
<p>Refer to this snippet of code extracted from <a class="el" href="examples.html#example_obj">examples/obj/main.cpp</a> as an example of how this functionality can be used. This code writes the tessellation data to an OBJ file. Note the use of <a class="el" href="classts3d_1_1_instance.html#aad98ca1a6d8bf0d554ba97b734acc471" title="Gets the net show. ">ts3d::Instance::getNetShow()</a> and <a class="el" href="group__eigen__bridge.html#gabe127bcb8cffb23d2b7de2b694a6cd8a" title="Gets the net matrix for a given instance.The matrix of each entry in the instance path is obtained an...">ts3d::getNetMatrix()</a>.</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> ri_instances = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( loader.m_psModelFile, kA3DTypeRiRepresentationItem );</div><div class="line">    <span class="keywordflow">for</span>( <span class="keyword">auto</span> ri_instance : ri_instances ) {</div><div class="line">        <a class="code" href="classts3d_1_1_representation_item_instance.html">ts3d::RepresentationItemInstance</a> <span class="keyword">const</span> ri( ri_instance );</div><div class="line">        <span class="keywordflow">if</span>( !ri.Instance::getNetShow() ) {</div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> tess3d = std::dynamic_pointer_cast&lt;<a class="code" href="classts3d_1_1_tess3_d_instance.html">ts3d::Tess3DInstance</a>&gt;( ri.getTessellation() );</div><div class="line">        <span class="keywordflow">if</span>( <span class="keyword">nullptr</span> == tess3d ) {</div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> name = ri.<a class="code" href="classts3d_1_1_instance.html#ad510254ee846664c4e9d39af70eef430">getName</a>();</div><div class="line">        obj_file &lt;&lt; <span class="stringliteral">&quot;o &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</div><div class="line">        </div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> net_style = ri.Instance::getNetStyle();</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> mtl = getMaterial( net_style );</div><div class="line">        <span class="keywordflow">if</span>( !mtl.empty() ) {</div><div class="line">            obj_file &lt;&lt; <span class="stringliteral">&quot;usemtl &quot;</span> &lt;&lt; mtl &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> net_matrix = <a class="code" href="group__eigen__bridge.html#gabe127bcb8cffb23d2b7de2b694a6cd8a">ts3d::getNetMatrix</a>( ri );</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> exchange_coords = tess3d-&gt;coords();</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> n_coords = tess3d-&gt;coordsSize();</div><div class="line">        <span class="keywordflow">for</span>( <span class="keyword">auto</span> idx = 0u; idx &lt; n_coords; idx += 3 ) {</div><div class="line">            <span class="keyword">auto</span> v = net_matrix * <a class="code" href="group__eigen__bridge.html#ga91df0d88af94bf5ac5fcab5ea5580bd4">ts3d::VectorType</a>( exchange_coords[idx], exchange_coords[idx+1], exchange_coords[idx+2], 1. );</div><div class="line">            obj_file &lt;&lt; <span class="stringliteral">&quot;v &quot;</span> &lt;&lt; v(0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; v(1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; v(2) &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> exchange_normals = tess3d-&gt;normals();</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> n_normals = tess3d-&gt;normalsSize();</div><div class="line">        <span class="keywordflow">for</span>( <span class="keyword">auto</span> idx = 0u; idx &lt; n_normals; idx += 3 ) {</div><div class="line">            <span class="keyword">auto</span> n = net_matrix * <a class="code" href="group__eigen__bridge.html#ga91df0d88af94bf5ac5fcab5ea5580bd4">ts3d::VectorType</a>( exchange_normals[idx], exchange_normals[idx+1], exchange_normals[idx+2], 0. );</div><div class="line">            obj_file &lt;&lt; <span class="stringliteral">&quot;vn &quot;</span> &lt;&lt; n(0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; n(1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; n(2) &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span>( <span class="keyword">auto</span> idx = 0u; idx &lt; tess3d-&gt;faceSize(); ++idx ) {</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> face_mesh = tess3d-&gt;getIndexMeshForFace( idx );</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> n_vertices = face_mesh.vertices().size();</div><div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span> idx = 0u; idx &lt; n_vertices; ++idx ) {</div><div class="line">                <span class="keywordflow">if</span>( 0 == idx % 3 ) {</div><div class="line">                    obj_file &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;f&quot;</span>;</div><div class="line">                }</div><div class="line">                </div><div class="line">                obj_file &lt;&lt; <span class="stringliteral">&quot; -&quot;</span> &lt;&lt; (n_coords - face_mesh.vertices()[idx])/3 &lt;&lt; <span class="stringliteral">&quot;//-&quot;</span> &lt;&lt; (n_normals - face_mesh.normals()[idx])/3;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        obj_file &lt;&lt; std::endl;</div><div class="line">    }</div></div><!-- fragment --> <h2><a class="anchor" id="Edges"></a>
Edges</h2>
<p><a class="el" href="classts3d_1_1_tess_face_data_helper.html" title="This is a helper class used to more easily provide access to the indexed mesh data for a given face...">ts3d::TessFaceDataHelper</a> provides a method for obtaining the loops of edges associated with the topological face it is associated with. <a class="el" href="classts3d_1_1_tess_face_data_helper.html#a6e7fa19d1b33afc4171e56b1e39868f1" title="Provides a list of TessLoop objects representing the edge loops that bound this face. ">ts3d::TessFaceDataHelper::loops()</a> returns an ordered collection of <a class="el" href="structts3d_1_1_tess_face_data_helper_1_1_tess_loop.html" title="A collection of TessEdge objects representing a single closed series of edges that bound a face...">ts3d::TessFaceDataHelper::TessLoop</a> objects. Each <code>TessLoop</code> contains an ordered collection of <a class="el" href="structts3d_1_1_tess_face_data_helper_1_1_tess_edge.html" title="Index list of vertices for the tessellation of a specific edge. ">ts3d::TessFaceDataHelper::TessEdge</a> objects. Each <code>TessEdge</code> contains a visibility flag, and an order collection of index values for the points of the polyline representing the edge.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="examples.html#example_compare_brep_tess">Comparing tessellation to B-Rep</a></dd></dl>
<h2><a class="anchor" id="Wires"></a>
Wires</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Implement and test wire tessellation objects </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This implementation is incomplete! </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
